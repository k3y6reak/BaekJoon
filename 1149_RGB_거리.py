# [아이디어]
# 단순하게 생각하면 빨강을 처음 선택하고 다음에 초록 또는 파랑을 선택, 다시 (빨강, 파랑), (빨강, 초록) 선택... 처럼 DFS를 생각할 수 있다.
# 일단, Python3이며, 언어제한 없이 0.5초라는 제약조건이 있어, DFS로는 쉽게 풀수 없을것같다.
# DP로 접근을 했는데, 빨강을 선택한 위치에서 이전 이웃집은 초록 또느 파랑 중 비용이 작은걸 선택하면 된다.
# 각 색깔별로 선택하고 가자 작은 값을 구해야한다.
#
#
#                  이전   <------ 빨강
#                이웃집에서          |
#                초록, 파랑         |
#               중, 작은 값         |
#                                 v
#     #########   #########   #########
#     #       #   #       #   #       #
#     #       #   #       #   #       #
#     #########   #########   #########

def main():
    R, G, B = 0, 1, 2
    n = int(input())
    rgbs = [[0, 0, 0]]
    rgbs += [list(map(int, input().split())) for _ in range(n)]
    dp = [[0]*3 for _ in range(n+1)]

    for i in range(1, n+1):
        dp[i][R] = rgbs[i][R] + min(dp[i-1][G], dp[i-1][B])
        dp[i][G] = rgbs[i][G] + min(dp[i-1][R], dp[i-1][B])
        dp[i][B] = rgbs[i][B] + min(dp[i-1][R], dp[i-1][G])

    print(min([dp[n][0], dp[n][1], dp[n][2]]))


if __name__ == '__main__':
    main()
